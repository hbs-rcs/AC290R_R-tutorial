---
title: Data Import
slug: data-import
author: Data Carpentry contributors, Michael Levy, Bob Freeman, & Andrew Marder
minutes: 20
weight: 20
---


------------

> ## Learning Objectives
>
> * load external data (CSV files) in memory
> * explore the structure and the content of the data in R
> * understand what are factors and how to manipulate them

------------

## Reading CSV data

The `continents` data.frame was useful for learning because it was so small, but it's time to graduate to something more interesting and realistic. Data come in many forms, and we need to be able to load them in R. For our own use and with others who use R, there are R-specific data structures we can use, like the .RDA file-type we just saw, but we need to be able to work with more general data types too. Comma-separated value (csv) tables are perhaps the most universal data structure. 

The gapminder dataset provides country-by-year level data on gdp, population, and longevity. I downloaded it and put it in the data directory of my project. You will do the same in a minute.

We can read csv's with the `read.csv` function. The argument to `read.csv` is the location of the file, relative to your working directory. Since I saved the gapminder data to the `data` directory of my project, I can load it with this. Note the use of tab-completion to find the file and get it exactly right without typos. 

```{r, eval=TRUE, results='hide'}
read.csv('data/gapminder-FiveYearData.csv')
```

Whoa! What just happened? R executed the function and printed the result, just like when you enter `log(1)`. How do you store an object to a variable?

```{r}
gapminder <- read.csv('data/gapminder-FiveYearData.csv')
```

This statement doesn't produce any output because assignment doesn't display
anything. But now, a data.frame called `gapminder` is in my Environment, and I can see that it is a data.frame with 1704 rows and 6 columns. If we want to check that our data has been loaded, we can print the
variable's value: `gapminder`

Alternatively, wrapping an assignment in parentheses will perform the assignment
and display it at the same time.

```{r, eval=TRUE, results='hide', purl = FALSE}
(gapminder <- read.csv('data/gapminder-FiveYearData.csv'))
```

Wow... that was a lot of output. At least it means the data loaded properly. Let's check the top (the first 6 lines) of this `data.frame` using the function `head()`:

```{r}
head(gapminder)
```

We've just done two very useful things.
1. We've read our data in to R, so now we can work with it in R
2. We've created a data frame (with the read.csv command) the 
standard way R works with data. 

A `data.frame` can be created by the functions `read.csv()` or `read.table()`, and can import 
local files or those from the web. These are usually text files in the shape of data 
tables that you might often import open in Microsoft Excel. If you wish to import Excel files,
you'll need to use an add-in (package) call XLConnect (see [this article](https://www.datacamp.com/community/tutorials/r-tutorial-read-excel-into-r#gs.njZB8ZI) for more information
on using Excel files). We'll briefly touch on packages later.

> #### Challenge -- read csv data
>
> Suppose you get a .csv file from a colleague in Europe. Because they use "," (comma) as a decimal separator, they use ";" (semi-colons) to separate fields. How can you read it into R? 
>
> Feel free to use the web and/or R's helpfiles.    
>


By default, `data.frame` converts (= coerces) columns that contain characters
(i.e., text) into the `factor` data type. Depending on what you want to do with
the data, you may want to keep these columns as `character`. To do so,
`read.csv()` and `read.table()` have an argument called `stringsAsFactors` which
can be set to `FALSE`:

```{r eval=TRUE}
gapminder <- read.csv('data/gapminder-FiveYearData.csv', stringsAsFactors = FALSE)
```

Let's now check the __str__ucture of this `data.frame` in more details with the
function `str()`:

```{r}
# get the dataframe back to the original load
gapminder <- read.csv('data/gapminder-FiveYearData.csv')
str(gapminder)
```

## Inspecting `data.frame` objects

We already saw how the functions `head()` and `str()` can be useful to check the
content and the structure of a `data.frame`. There are additional functions that can be
useful in helping to assess the structure and content of your data. Note: most of these 
functions are "generic", they can be used on other types of objects besides a `data.frame`.

### Size

Three commands will allow you to see the shape of your data. `dim()` will return a vector 
with the number of rows in the first element, and
the number of columns as the second element (the __dim__ensions of the object)

```{r}
dim(gapminder)
```

You can also assess these independently using both the `nrow()` and `ncol()` functions:

```{r}
nrow(gapminder)
ncol(gapminder)
```


### Content

As we've already seen the `head()` command, what might you guess is the complementary command
to look at the bottom of the data?

```{r}
tail(gapminder)
````


### Names

If your dataset has column headers, this information can be retrieved with the `colnames()` command.
More colloquially, you can use `names()` if your object is a `data.frame`.

```{r}
colnames(gapminder)
````
```{r}
names(gapminder)
````

Likewise, the `rownames()` command will retrieve the row headers, if present. If not, this
command will simply return the row number:

```{r}
# head this so the list isn't long
head(rownames(gapminder), n = 24L)
````


### Summary

You've already seen the structure command `str()`, to inspect the composition of the data object:

```{r}
str(gapminder)
````

Equally as valuable is the `summary()` command, which will give you summary statistics 
for each column:

```{r}
summary(gapminder)
````

As you can see, this information is more valuable for some columns than others.  **CHALLENGE!**


> ### Challenge
> 
> Based on the functions you've learned to asses data structure, can you answer the following questions?
> 
> * What is the class of the column `continent`?
> * The summary() function doesn't make sense for the whole gapminder object (variable). What command
> would you use to get a summary of the population?
>

As you can see, many of the columns in our data frame are of a special class called
`factor`. Before we learn more about the `data.frame` class, we are going to
talk about factors. They are very useful but not necessarily intuitive, and
therefore require some attention.


## Factors

Factors are used to represent categorical data. Factors can be ordered or
unordered and are an important class for statistical analysis and for plotting.

Factors are stored as integers, and have labels associated with these unique
integers. While factors look (and often behave) like character vectors, they are
actually integers under the hood, and you need to be careful when treating them
like strings.

Once created, factors can only contain a pre-defined set values, known as
levels. By default, R always sorts levels in alphabetical order. For
instance, if you have a factor with 2 levels:

```{r, purl=TRUE}
continent <- factor(c("Europe", "Americas", "Oceana", "Europe", "Africa", "Africa"))
```

R will assign `1` to the level `Africa` and `2` to the level `Americas` (because
`Af` comes before `Am`, even though the first element in this vector is
`Europe`). You can check this by using the function `levels()`, and check the
number of levels using `nlevels()`:

```{r, purl=FALSE}
levels(continent)
nlevels(continent)
```

Sometimes, the order of the factors does not matter, other times you might want
to specify the order because it is meaningful (e.g., "low", "medium", "high") or
it is required by particular type of analysis. Additionally, specifying the
order of the levels allows to compare levels:

```{r, purl=FALSE, error=TRUE, collapse=TRUE}
gdp <- factor(c("low", "high", "medium", "high", "low", "medium", "high"))
levels(gdp)
gdp <- factor(gdp, levels=c("low", "medium", "high"))
levels(gdp)
min(gdp) ## doesn't work
gdp <- factor(gdp, levels=c("low", "medium", "high"), ordered=TRUE)
levels(gdp)
min(gdp) ## works!
```

In R's memory, these factors are represented by numbers (1, 2, 3). They are
better than using simple integer labels because factors are self describing:
`low`, `medium`, and `high` is more descriptive than `1`, `2`, `3`. Which
is low? You wouldn't be able to tell with just integer data. Factors have this
information built in. It is particularly helpful when there are many levels.

### Converting factors

If you need to convert a factor to a character vector, simply use
`as.character(x)`.

Converting a factor to a numeric vector is however a little trickier, and you
have to go via a character vector. Compare:

```{r, purl=TRUE, eval=TRUE, collapse=TRUE}
f <- factor(c(1, 5, 10, 2))
as.numeric(f)               ## wrong! and there is no warning...
as.numeric(as.character(f)) ## works...
as.numeric(levels(f))[f]    ## The recommended way.
```
&nbsp;

> #### Challenge
>  
> The function `table()` tabulates observations and can be used to create
> bar plots quickly. For instance:
> 
> ```{r wrong-order, purl=TRUE, collapse=TRUE}
> continent <- factor(c("Oceana", "Americas", "Asia", "Africa", "Europe", "Europe",
>                    "Asia", "Africa", "Europe"))
> table(continent)
> barplot(table(continent))
> ```
>  
> 1) How can you recreate this plot but by having "Europe" and
> "Americas" being listed as the first two?
> 
> <!---
> ```{r correct-order, purl=FALSE, eval=TRUE, echo=FALSE}
> continent <- factor(continent, levels=c("Europe", "Americas", "Asia", "Africa", "Oceana"))
> barplot(table(continent))
> ```
> --->
> 
> 2) We've read in the gapminder data by default which includes the categorical data as factors.
> But this doesn't make sense for part of the data. Using what you've learned in this lesson
> and the previous one, use your R knowledge to create the gapminder dataframe such that
> only continents is represented as a factor, and order it such that Europe and Americas
> are the first two continents.
> 
> <!---
> ```{r correct-gapminder-factor, purl=FALSE, eval=TRUE, echo=FALSE}
> gapminder <- read.csv('data/gapminder-FiveYearData.csv', stringsAsFactors = FALSE)
> gapminder$continent <- factor(gapminder$continent, 
>                                levels=c("Europe", "Americas", "Asia", "Africa", "Oceana"))
> ```
> --->

# Learning Objectives

*   Understand the concept of a `data.frame`
*   Learn how to create new `data.frame` objects
*   Use sequences to index data
*   Know how to access any element of a `data.frame`


# What is a Data Frame?

The `data.frame` class of objects is the de facto data structure for most tabular data, we use data frames for statistics and plotting.

A `data.frame` object is a collection of vectors of identical lengths. Each vector represents a column, and each vector can be of a different data type (characters, integers, factors, ...). The `str()` function is useful to inspect the data types of the columns.


# Creating a Data Frame

In this section, we create a `data.frame` object by hand to see what goes into making a `data.frame` and to get an idea of what data frames look like. Then we create another data frame by reading data from a file.

## Manual Creation

You can create a `data.frame` manually with the function `data.frame()`.

```{r}
animals <- data.frame(
    name = c("Andrew", "Bob", "Carl", "Doug"),
    feel = c("Furry", "Furry", "Squishy", "Spiny"),
    type = c("Dog", "Cat", "Sea Cucumber", "Sea Urchin"),
    weight_lbs = c(45, 8, 1.1, 0.8)
)
```

Let's look at the `data.frame` we've created.

```{r}
animals
```

We have created a table of animals. There are four rows (animals) and four columns (characteristics of each animal). Andrew is a furry dog that weighs 45 pounds.

If you want to see the data type of each column or you're working with a large data frame and you don't want to print all of the data, the `str()` function is very useful for inspecting the structure of a data frame.

```{r}
str(animals)
```

## Reading From a File

The `data.frame()` function is not the only way to create `data.frame` objects. In this section we use the `load()` and `read.csv()` functions to create new data frames.

R comes with functions to `save()` objects to files and `load()` objects that have been saved to files. R uses its own binary file format. Files saved in this manner typically have a file extensions of `.RData`, `.rda`, or `.RDA`. Multiple objects can be saved to the same R data file, the `load()` function loads all the objects stored in the file. To see what objects have been loaded set the `verbose` argument to `TRUE`. Let's load a `data.frame` of continents:

```{r}
load('data/continents.RDA', verbose = TRUE)
```

This creates a new `data.frame` object called `continents`. Let's take a look at the data:

```{r}
continents
```

There are 6 rows and 4 columns of data in this table of continents. Notice how much easier it was to read a `data.frame` from a file than to create it manually.

Now let's create a `data.frame` from data contained in a CSV (Comma-Separated Values) file. This is one of most common ways to import data contained in a spreadsheet into R.

```{r}
gapminder <- read.csv("data/gapminder-FiveYearData.csv")
```

This data file is much larger than the data frames we have been working with. It has `r nrow(gapminder)` rows, so printing all the data would be a little messy. The `str()` function is useful for looking at the structure of a `data.frame`.

```{r}
str(gapminder)
```

By default, `data.frame()` converts (= coerces) columns that contain characters
(i.e., text) into the `factor` data type. Depending on what you want to do with
the data, you may want to keep these columns as `character`. To do so,
`read.csv()` and `read.table()` have an argument called `stringsAsFactors` which
can be set to `FALSE`.


# Sequences

The colon character `:` is a special operator that creates numeric vectors in increasing or decreasing order. Try it out:

```{r}
1:10
10:1
```

The function `seq()` can be used to create more complicate sequences of numbers:

```{r}
seq(1, 10, by=2)
seq(5, 10, length.out=3)       # equal breaks of sequence into vector length = length.out
seq(50, by=5, length.out=10)   # sequence 50 by 5 until you hit vector length = length.out
seq(1, 8, by=3)                # sequence by 3 until you hit 8
```

The `:` operator and `seq()` function are useful in many contexts, particularly when indexing vectors and data frames.


# Indexing

Although we have created data frames in R, we don't really know how to interact with these objects. For instance, how do we subset a data frame, selecting specific columns or rows? This section introduces how one selects specific data out of a vector and then how to do the same for a data frame.

## Vectors

To illustrate how to extract one or several values from a vector, let's create a new vector. 

```{r}
x <- c("h", "e", "l", "l", "o")
```

`x` is a character vector that has five elements. Like working with vectors in math, to select a specific element of the vector we use square brackets. What is the second element of `x`?

```{r}
x[2]
```

What happens when we select elements at multiple indices?

```{r}
x[c(3, 2)]
x[2:4]
x[c(3, 2, 2:4)]
```

R indexes start at 1. Programming languages like Fortran, MATLAB, and R start counting at 1, because that's what human beings typically do. Languages in the C family (including C++, Java, Perl, and Python) start counting at 0.


## Data Frames

A data frame has rows and columns (it has 2 dimensions). If we want to extract some specific data, we need to specify the "coordinates" we want from it. Row numbers come first, followed by column numbers (i.e. [row, column]).

```{r}
continents[1, 1]   # first element in the first column of the data frame
continents[1, 3]   # first element in the 3rd column
continents[1:3, 4] # first three elements in the 4th column
continents[3, ]    # the 3rd row
continents[, 4]    # the 4th column

first_three_rows <- continents[1:3, ]
```

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

**Challenge**

Calling the function `nrow()` on a `data.frame` returns the number of rows in that data frame. Use it, in conjuction with `seq()` to create a new `data.frame` called `even_continents` that includes every other row of the continents data frame starting at row 2 (2, 4, ...).
   
```{r, echo = FALSE}
i <- seq(2, nrow(continents), by = 2)
even_continents <- continents[i, ]
```

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

For larger datasets, it can be tricky to remember the column number that corresponds to a particular variable. (Are population counts in column 3 or 4? oh, right... they are in column 3). In some cases, in which column the variable will be can change if the script you are using adds or removes columns. It's therefore often better to use column names to refer to a particular variable, and it makes your code easier to read and your intentions clearer.

You can do operations on a particular column, by selecting it using the `$` operator. In this case, the entire column is a vector. You can use `names(continents)` or `colnames(continents)` to remind yourself of the column names. For instance, to extract all the continent names from our dataset:

```{r}
continents$continent
```

In some cases, you may want to select more than one column. You can do this using the square brackets. Suppose we wanted continent and percent_total_pop information:

```{r}
continents[, c("continent", "percent_total_pop")]
```

You can even access columns by column name and select specific rows of interest. For example, if we wanted the continent and percent_total_pop of just rows
2 through 4, we could do:

```{r}
continents[2:4, c("continent", "percent_total_pop")]
```
